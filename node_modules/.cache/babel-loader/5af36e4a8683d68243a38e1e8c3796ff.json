{"ast":null,"code":"\"use strict\";\n\nconst DocumentType = require(\"../living/generated/DocumentType\");\n\nconst DocumentFragment = require(\"../living/generated/DocumentFragment\");\n\nconst Text = require(\"../living/generated/Text\");\n\nconst Comment = require(\"../living/generated/Comment\");\n\nconst attributes = require(\"../living/attributes\");\n\nconst nodeTypes = require(\"../living/node-type\");\n\nconst serializationAdapter = require(\"./parse5-adapter-serialization\");\n\nmodule.exports = class JSDOMParse5Adapter {\n  constructor(documentImpl) {\n    this._documentImpl = documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], {\n      ownerDocument: this._documentImpl\n    });\n  }\n\n  createElement(localName, namespace, attrs) {\n    const element = this._documentImpl._createElementWithCorrectElementInterface(localName, namespace);\n\n    element._namespaceURI = namespace;\n    this.adoptAttributes(element, attrs);\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    return Comment.createImpl([], {\n      data,\n      ownerDocument: this._documentImpl\n    });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode.appendChild(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    // parse5 sometimes gives us these as null.\n    if (name === null) {\n      name = \"\";\n    }\n\n    if (publicId === null) {\n      publicId = \"\";\n    }\n\n    if (systemId === null) {\n      systemId = \"\";\n    }\n\n    const documentType = DocumentType.createImpl([], {\n      name,\n      publicId,\n      systemId,\n      ownerDocument: this._documentImpl\n    });\n    document.appendChild(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const lastChild = parentNode.lastChild;\n\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const textNode = Text.createImpl([], {\n        data: text,\n        ownerDocument: this._documentImpl\n      });\n      parentNode.appendChild(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const previousSibling = referenceNode.previousSibling;\n\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const textNode = Text.createImpl([], {\n        data: text,\n        ownerDocument: this._documentImpl\n      });\n      parentNode.insertBefore(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n\n};\nObject.assign(module.exports.prototype, serializationAdapter);","map":null,"metadata":{},"sourceType":"script"}