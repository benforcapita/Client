{"ast":null,"code":"\"use strict\";\n\nconst vm = require(\"vm\");\n\nconst whatwgEncoding = require(\"whatwg-encoding\");\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nconst _require = require(\"../../utils\"),\n      reflectURLAttribute = _require.reflectURLAttribute;\n\nconst resourceLoader = require(\"../../browser/resource-loader\");\n\nconst reportException = require(\"../helpers/runtime-script-errors\");\n\nconst _require2 = require(\"../helpers/internal-constants\"),\n      domSymbolTree = _require2.domSymbolTree;\n\nconst _require3 = require(\"../helpers/strings\"),\n      asciiLowercase = _require3.asciiLowercase;\n\nconst _require4 = require(\"../helpers/text\"),\n      childTextContent = _require4.childTextContent;\n\nconst nodeTypes = require(\"../node-type\");\n\nconst jsMIMETypes = new Set([\"application/ecmascript\", \"application/javascript\", \"application/x-ecmascript\", \"application/x-javascript\", \"text/ecmascript\", \"text/javascript\", \"text/javascript1.0\", \"text/javascript1.1\", \"text/javascript1.2\", \"text/javascript1.3\", \"text/javascript1.4\", \"text/javascript1.5\", \"text/jscript\", \"text/livescript\", \"text/x-ecmascript\", \"text/x-javascript\"]);\n\nclass HTMLScriptElementImpl extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n    this._alreadyStarted = false;\n    this._parserInserted = false; // set by the parser\n  }\n\n  _attach() {\n    super._attach(); // In our current terribly-hacky document.write() implementation, we parse in a div them move elements into the main\n    // document. Thus _eval() will bail early when it gets in _poppedOffStackOfOpenElements(), since we're not attached\n    // then. Instead, we'll let it eval here.\n\n\n    if (!this._parserInserted || this._isMovingDueToDocumentWrite) {\n      this._eval();\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    super._attrModified(name, value, oldValue);\n\n    if (this._attached && !this._startedEval && name === \"src\" && oldValue === null && value !== null) {\n      resourceLoader.load(this, this.src, {\n        defaultEncoding: whatwgEncoding.labelToName(this.getAttribute(\"charset\")) || this._ownerDocument._encoding\n      }, this._innerEval);\n    }\n  }\n\n  _poppedOffStackOfOpenElements() {\n    // This seems to roughly correspond to\n    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-incdata:prepare-a-script, although we certainly\n    // don't implement the full semantics.\n    this._eval();\n  } // Vaguely similar to https://html.spec.whatwg.org/multipage/scripting.html#prepare-a-script, but we have a long way\n  // to go before it's aligned.\n\n\n  _eval() {\n    if (this._alreadyStarted) {\n      return;\n    } // TODO: this text check doesn't seem completely the same as the spec, which e.g. will try to execute scripts with\n    // child element nodes. Spec bug? https://github.com/whatwg/html/issues/3419\n\n\n    if (!this.hasAttribute(\"src\") && this.text.length === 0) {\n      return;\n    }\n\n    if (!this._attached) {\n      return;\n    }\n\n    const scriptBlocksTypeString = this._getTypeString();\n\n    const type = getType(scriptBlocksTypeString);\n\n    if (type !== \"classic\") {\n      // TODO: implement modules, and then change the check to `type === null`.\n      return;\n    }\n\n    this._alreadyStarted = true; // Equivalent to the spec's \"scripting is disabled\" check.\n\n    if (!this._ownerDocument._defaultView || this._ownerDocument._defaultView._runScripts !== \"dangerously\") {\n      return;\n    } // TODO: implement nomodule here, **but only after we support modules**.\n    // At this point we completely depart from the spec.\n\n\n    if (this.hasAttribute(\"src\")) {\n      resourceLoader.load(this, this.src, {\n        defaultEncoding: whatwgEncoding.labelToName(this.getAttribute(\"charset\")) || this._ownerDocument._encoding\n      }, this._innerEval);\n    } else {\n      resourceLoader.enqueue(this, this._ownerDocument.URL, this._innerEval)(null, this.text);\n    }\n  }\n\n  _innerEval(text, filename) {\n    this._ownerDocument._writeAfterElement = this;\n    processJavaScript(this, text, filename);\n    delete this._ownerDocument._writeAfterElement;\n  }\n\n  _getTypeString() {\n    const typeAttr = this.getAttribute(\"type\");\n    const langAttr = this.getAttribute(\"language\");\n\n    if (typeAttr === \"\") {\n      return \"text/javascript\";\n    }\n\n    if (typeAttr === null && langAttr === \"\") {\n      return \"text/javascript\";\n    }\n\n    if (typeAttr === null && langAttr === null) {\n      return \"text/javascript\";\n    }\n\n    if (typeAttr !== null) {\n      return typeAttr.trim();\n    }\n\n    if (langAttr !== null) {\n      return \"text/\" + langAttr;\n    }\n\n    return null;\n  }\n\n  get text() {\n    return childTextContent(this);\n  }\n\n  set text(text) {\n    this.textContent = text;\n  }\n\n  get src() {\n    return reflectURLAttribute(this, \"src\");\n  }\n\n  set src(V) {\n    this.setAttribute(\"src\", V);\n  }\n\n}\n\nfunction processJavaScript(element, code, filename) {\n  const document = element.ownerDocument;\n  const window = document && document._global;\n\n  if (window) {\n    document._currentScript = element;\n    let lineOffset = 0;\n\n    if (!element.src) {\n      for (const child of domSymbolTree.childrenIterator(element)) {\n        if (child.nodeType === nodeTypes.TEXT_NODE) {\n          if (child.__location) {\n            lineOffset = child.__location.line - 1;\n          }\n\n          break;\n        }\n      }\n    }\n\n    try {\n      vm.runInContext(code, window, {\n        filename,\n        lineOffset,\n        displayErrors: false\n      });\n    } catch (e) {\n      reportException(window, e, filename);\n    } finally {\n      document._currentScript = null;\n    }\n  }\n}\n\nfunction getType(typeString) {\n  const lowercased = asciiLowercase(typeString); // Cannot use whatwg-mimetype parsing because that strips whitespace. The spec demands a strict string comparison.\n  // That is, the type=\"\" attribute is not really related to MIME types at all.\n\n  if (jsMIMETypes.has(lowercased)) {\n    return \"classic\";\n  }\n\n  if (lowercased === \"module\") {\n    return \"module\";\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  implementation: HTMLScriptElementImpl\n};","map":null,"metadata":{},"sourceType":"script"}