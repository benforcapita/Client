{"ast":null,"code":"\"use strict\";\n\nconst _require = require(\"../helpers/selectors\"),\n      addNwsapi = _require.addNwsapi;\n\nconst _require2 = require(\"../helpers/namespaces\"),\n      HTML_NS = _require2.HTML_NS;\n\nconst _require3 = require(\"../../utils\"),\n      mixin = _require3.mixin,\n      memoizeQuery = _require3.memoizeQuery;\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\n\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nconst ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\n\nconst attributes = require(\"../attributes\");\n\nconst namedPropertiesWindow = require(\"../named-properties-window\");\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst _require4 = require(\"../../browser/domtohtml\"),\n      domToHtml = _require4.domToHtml;\n\nconst _require5 = require(\"../helpers/internal-constants\"),\n      domSymbolTree = _require5.domSymbolTree;\n\nconst DOMException = require(\"domexception\");\n\nconst DOMTokenList = require(\"../generated/DOMTokenList\");\n\nconst attrGenerated = require(\"../generated/Attr\");\n\nconst NamedNodeMap = require(\"../generated/NamedNodeMap\");\n\nconst validateNames = require(\"../helpers/validate-names\");\n\nconst _require6 = require(\"../helpers/strings\"),\n      asciiLowercase = _require6.asciiLowercase;\n\nconst _require7 = require(\"../node\"),\n      clone = _require7.clone,\n      listOfElementsWithQualifiedName = _require7.listOfElementsWithQualifiedName,\n      listOfElementsWithNamespaceAndLocalName = _require7.listOfElementsWithNamespaceAndLocalName,\n      listOfElementsWithClassNames = _require7.listOfElementsWithClassNames;\n\nconst NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode-impl\").implementation;\n\nfunction clearChildNodes(node) {\n  for (let child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nfunction setInnerHTML(document, node, html) {\n  // Clear the children first:\n  if (node._templateContents) {\n    clearChildNodes(node._templateContents);\n  } else {\n    clearChildNodes(node);\n  }\n\n  if (node.nodeName === \"#document\") {\n    document._htmlToDom.appendToDocument(html, node);\n  } else {\n    document._htmlToDom.appendToNode(html, node);\n  }\n}\n\nfunction attachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n\n    doc._ids[id].push(elm);\n  }\n}\n\nfunction detachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      const elms = doc._ids[id];\n\n      for (let i = 0; i < elms.length; i++) {\n        if (elms[i] === elm) {\n          elms.splice(i, 1);\n          --i;\n        }\n      }\n\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n}\n\nclass ElementImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n    this.nodeType = NODE_TYPE.ELEMENT_NODE;\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n    this._namespaceURI = privateData.namespace || null;\n    this._prefix = null;\n    this._localName = privateData.localName;\n    this._attributeList = []; // Used for caching.\n\n    this._attributesByNameMap = new Map();\n    this._attributes = NamedNodeMap.createImpl([], {\n      element: this\n    });\n  }\n\n  _attach() {\n    namedPropertiesWindow.nodeAttachedToDocument(this);\n    const id = this.getAttribute(\"id\");\n\n    if (id) {\n      attachId(id, this, this._ownerDocument);\n    }\n\n    super._attach();\n  }\n\n  _detach() {\n    super._detach();\n\n    namedPropertiesWindow.nodeDetachedFromDocument(this);\n    const id = this.getAttribute(\"id\");\n\n    if (id) {\n      detachId(id, this, this._ownerDocument);\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    this._modified();\n\n    namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);\n\n    if (name === \"id\" && this._attached) {\n      const doc = this._ownerDocument;\n      detachId(oldValue, this, doc);\n      attachId(value, this, doc);\n    } // update classList\n\n\n    if (name === \"class\" && this._classList !== undefined) {\n      this._classList.attrModified();\n    }\n  }\n\n  get namespaceURI() {\n    return this._namespaceURI;\n  }\n\n  get prefix() {\n    return this._prefix;\n  }\n\n  get localName() {\n    return this._localName;\n  }\n\n  get _qualifiedName() {\n    return this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n  }\n\n  get tagName() {\n    let qualifiedName = this._qualifiedName;\n\n    if (this.namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = qualifiedName.toUpperCase();\n    }\n\n    return qualifiedName;\n  }\n\n  get attributes() {\n    return this._attributes;\n  }\n\n  get outerHTML() {\n    return domToHtml([this]);\n  }\n\n  set outerHTML(html) {\n    if (html === null) {\n      html = \"\";\n    }\n\n    const parent = domSymbolTree.parent(this);\n    const document = this._ownerDocument;\n\n    if (!parent) {\n      return;\n    }\n\n    let contextElement;\n\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(\"Modifications are not allowed for this document\", \"NoModificationAllowedError\");\n    } else if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      contextElement = document.createElementNS(HTML_NS, \"body\");\n    } else if (parent.nodeType === NODE_TYPE.ELEMENT_NODE) {\n      contextElement = clone(parent, undefined, false);\n    } else {\n      throw new TypeError(\"This should never happen\");\n    }\n\n    document._htmlToDom.appendToNode(html, contextElement);\n\n    while (contextElement.firstChild) {\n      parent.insertBefore(contextElement.firstChild, this);\n    }\n\n    parent.removeChild(this);\n  }\n\n  get innerHTML() {\n    // TODO is this necessary? I would have thought this would be handled at a different level.\n    const tagName = this.tagName;\n\n    if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n      const type = this.getAttribute(\"type\");\n\n      if (!type || /^text\\//i.test(type) || /\\/javascript$/i.test(type)) {\n        return domToHtml(domSymbolTree.childrenIterator(this));\n      }\n    } // In case of <template> we should pass its \"template contents\" fragment as a serialization root if we have one\n\n\n    if (this._templateContents) {\n      return domToHtml(domSymbolTree.childrenIterator(this._templateContents));\n    }\n\n    return domToHtml(domSymbolTree.childrenIterator(this));\n  }\n\n  set innerHTML(html) {\n    if (html === null) {\n      html = \"\";\n    }\n\n    setInnerHTML(this.ownerDocument, this, html);\n  }\n\n  get classList() {\n    if (this._classList === undefined) {\n      this._classList = DOMTokenList.createImpl([], {\n        element: this,\n        attributeLocalName: \"class\"\n      });\n    }\n\n    return this._classList;\n  }\n\n  hasAttributes() {\n    return attributes.hasAttributes(this);\n  }\n\n  getAttributeNames() {\n    return attributes.attributeNames(this);\n  }\n\n  getAttribute(name) {\n    const attr = attributes.getAttributeByName(this, name);\n\n    if (!attr) {\n      return null;\n    }\n\n    return attr._value;\n  }\n\n  getAttributeNS(namespace, localName) {\n    const attr = attributes.getAttributeByNameNS(this, namespace, localName);\n\n    if (!attr) {\n      return null;\n    }\n\n    return attr._value;\n  }\n\n  setAttribute(name, value) {\n    validateNames.name(name);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    const attribute = attributes.getAttributeByName(this, name);\n\n    if (attribute === null) {\n      const newAttr = attrGenerated.createImpl([], {\n        localName: name,\n        value\n      });\n      attributes.appendAttribute(this, newAttr);\n      return;\n    }\n\n    attributes.changeAttribute(this, attribute, value);\n  }\n\n  setAttributeNS(namespace, name, value) {\n    const extracted = validateNames.validateAndExtract(namespace, name);\n    attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);\n  }\n\n  removeAttribute(name) {\n    attributes.removeAttributeByName(this, name);\n  }\n\n  removeAttributeNS(namespace, localName) {\n    attributes.removeAttributeByNameNS(this, namespace, localName);\n  }\n\n  hasAttribute(name) {\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    return attributes.hasAttributeByName(this, name);\n  }\n\n  hasAttributeNS(namespace, localName) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    return attributes.hasAttributeByNameNS(this, namespace, localName);\n  }\n\n  getAttributeNode(name) {\n    return attributes.getAttributeByName(this, name);\n  }\n\n  getAttributeNodeNS(namespace, localName) {\n    return attributes.getAttributeByNameNS(this, namespace, localName);\n  }\n\n  setAttributeNode(attr) {\n    return attributes.setAttribute(this, attr);\n  }\n\n  setAttributeNodeNS(attr) {\n    return attributes.setAttribute(this, attr);\n  }\n\n  removeAttributeNode(attr) {\n    if (!attributes.hasAttribute(this, attr)) {\n      throw new DOMException(\"Tried to remove an attribute that was not present\", \"NotFoundError\");\n    }\n\n    attributes.removeAttribute(this, attr);\n    return attr;\n  }\n\n  getBoundingClientRect() {\n    return {\n      bottom: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      width: 0\n    };\n  }\n\n  getClientRects() {\n    return [];\n  }\n\n  get scrollWidth() {\n    return 0;\n  }\n\n  get scrollHeight() {\n    return 0;\n  }\n\n  get clientTop() {\n    return 0;\n  }\n\n  get clientLeft() {\n    return 0;\n  }\n\n  get clientWidth() {\n    return 0;\n  }\n\n  get clientHeight() {\n    return 0;\n  } // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\n\n\n  insertAdjacentHTML(position, text) {\n    position = position.toLowerCase();\n    let context;\n\n    switch (position) {\n      case \"beforebegin\":\n      case \"afterend\":\n        {\n          context = this.parentNode;\n\n          if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n            throw new DOMException(\"Cannot insert HTML adjacent to \" + \"parent-less nodes or children of document nodes.\", \"NoModificationAllowedError\");\n          }\n\n          break;\n        }\n\n      case \"afterbegin\":\n      case \"beforeend\":\n        {\n          context = this;\n          break;\n        }\n\n      default:\n        {\n          throw new DOMException(\"Must provide one of \\\"beforebegin\\\", \\\"afterend\\\", \" + \"\\\"afterbegin\\\", or \\\"beforeend\\\".\", \"SyntaxError\");\n        }\n    } // TODO: use context for parsing instead of a <template>.\n\n\n    const fragment = this.ownerDocument.createElement(\"template\");\n    fragment.innerHTML = text;\n\n    switch (position) {\n      case \"beforebegin\":\n        {\n          this.parentNode.insertBefore(fragment.content, this);\n          break;\n        }\n\n      case \"afterbegin\":\n        {\n          this.insertBefore(fragment.content, this.firstChild);\n          break;\n        }\n\n      case \"beforeend\":\n        {\n          this.appendChild(fragment.content);\n          break;\n        }\n\n      case \"afterend\":\n        {\n          this.parentNode.insertBefore(fragment.content, this.nextSibling);\n          break;\n        }\n    }\n  }\n\n  closest(selectors) {\n    const matcher = addNwsapi(this);\n    return matcher.closest(selectors, idlUtils.wrapperForImpl(this));\n  }\n\n}\n\nmixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);\nmixin(ElementImpl.prototype, ParentNodeImpl.prototype);\nmixin(ElementImpl.prototype, ChildNodeImpl.prototype);\nElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\nElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\nElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\nElementImpl.prototype.matches = memoizeQuery(function (selectors) {\n  const matcher = addNwsapi(this);\n  return matcher.match(selectors, idlUtils.wrapperForImpl(this));\n});\nElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;\nmodule.exports = {\n  implementation: ElementImpl\n};","map":null,"metadata":{},"sourceType":"script"}