{"ast":null,"code":"\"use strict\";\n\nconst _require = require(\"tough-cookie\"),\n      CookieJar = _require.CookieJar;\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst _require2 = require(\"../../utils\"),\n      mixin = _require2.mixin,\n      memoizeQuery = _require2.memoizeQuery;\n\nconst _require3 = require(\"../helpers/traversal\"),\n      firstChildWithHTMLLocalName = _require3.firstChildWithHTMLLocalName,\n      firstChildWithHTMLLocalNames = _require3.firstChildWithHTMLLocalNames,\n      firstDescendantWithHTMLLocalName = _require3.firstDescendantWithHTMLLocalName;\n\nconst whatwgURL = require(\"whatwg-url\");\n\nconst _require4 = require(\"../../level2/style\"),\n      StyleSheetList = _require4.StyleSheetList;\n\nconst _require5 = require(\"../helpers/internal-constants\"),\n      domSymbolTree = _require5.domSymbolTree;\n\nconst eventAccessors = require(\"../helpers/create-event-accessor\");\n\nconst _require6 = require(\"../helpers/strings\"),\n      asciiLowercase = _require6.asciiLowercase,\n      stripAndCollapseASCIIWhitespace = _require6.stripAndCollapseASCIIWhitespace;\n\nconst _require7 = require(\"../helpers/namespaces\"),\n      HTML_NS = _require7.HTML_NS,\n      SVG_NS = _require7.SVG_NS;\n\nconst DOMException = require(\"domexception\");\n\nconst HTMLToDOM = require(\"../../browser/htmltodom\");\n\nconst History = require(\"../generated/History\");\n\nconst Location = require(\"../generated/Location\");\n\nconst HTMLCollection = require(\"../generated/HTMLCollection\");\n\nconst NodeList = require(\"../generated/NodeList\");\n\nconst validateName = require(\"../helpers/validate-names\").name;\n\nconst _require8 = require(\"../helpers/validate-names\"),\n      validateAndExtract = _require8.validateAndExtract;\n\nconst resourceLoader = require(\"../../browser/resource-loader\");\n\nconst GlobalEventHandlersImpl = require(\"./GlobalEventHandlers-impl\").implementation;\n\nconst _require9 = require(\"../node\"),\n      clone = _require9.clone,\n      listOfElementsWithQualifiedName = _require9.listOfElementsWithQualifiedName,\n      listOfElementsWithNamespaceAndLocalName = _require9.listOfElementsWithNamespaceAndLocalName,\n      listOfElementsWithClassNames = _require9.listOfElementsWithClassNames;\n\nconst generatedAttr = require(\"../generated/Attr\");\n\nconst Comment = require(\"../generated/Comment\");\n\nconst ProcessingInstruction = require(\"../generated/ProcessingInstruction\");\n\nconst CDATASection = require(\"../generated/CDATASection\");\n\nconst Text = require(\"../generated/Text\");\n\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\n\nconst DOMImplementation = require(\"../generated/DOMImplementation\");\n\nconst NonElementParentNodeImpl = require(\"./NonElementParentNode-impl\").implementation;\n\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nconst Element = require(\"../generated/Element\");\n\nconst HTMLUnknownElement = require(\"../generated/HTMLUnknownElement\");\n\nconst SVGElement = require(\"../generated/SVGElement\");\n\nconst TreeWalker = require(\"../generated/TreeWalker\");\n\nconst NodeIterator = require(\"../generated/NodeIterator\");\n\nconst CustomEvent = require(\"../generated/CustomEvent\");\n\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\n\nconst Event = require(\"../generated/Event\");\n\nconst FocusEvent = require(\"../generated/FocusEvent\");\n\nconst HashChangeEvent = require(\"../generated/HashChangeEvent\");\n\nconst KeyboardEvent = require(\"../generated/KeyboardEvent\");\n\nconst MessageEvent = require(\"../generated/MessageEvent\");\n\nconst MouseEvent = require(\"../generated/MouseEvent\");\n\nconst PopStateEvent = require(\"../generated/PopStateEvent\");\n\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\n\nconst TouchEvent = require(\"../generated/TouchEvent\");\n\nconst UIEvent = require(\"../generated/UIEvent\");\n\nfunction clearChildNodes(node) {\n  for (let child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nclass ResourceQueue {\n  constructor(paused) {\n    this.paused = Boolean(paused);\n  }\n\n  push(callback) {\n    const q = this;\n    const item = {\n      prev: q.tail,\n\n      check() {\n        if (!q.paused && !this.prev && this.fired) {\n          callback(this.err, this.data, this.response);\n\n          if (this.next) {\n            this.next.prev = null;\n            this.next.check();\n          } else {\n            // q.tail===this\n            q.tail = null;\n          }\n        }\n      }\n\n    };\n\n    if (q.tail) {\n      q.tail.next = item;\n    }\n\n    q.tail = item;\n    return (err, data, response) => {\n      item.fired = 1;\n      item.err = err;\n      item.data = data;\n      item.response = response;\n      item.check();\n    };\n  }\n\n  resume() {\n    if (!this.paused) {\n      return;\n    }\n\n    this.paused = false;\n    let head = this.tail;\n\n    while (head && head.prev) {\n      head = head.prev;\n    }\n\n    if (head) {\n      head.check();\n    }\n  }\n\n}\n\nclass RequestManager {\n  constructor() {\n    this.openedRequests = [];\n  }\n\n  add(req) {\n    this.openedRequests.push(req);\n  }\n\n  remove(req) {\n    const idx = this.openedRequests.indexOf(req);\n\n    if (idx !== -1) {\n      this.openedRequests.splice(idx, 1);\n    }\n  }\n\n  close() {\n    for (const openedRequest of this.openedRequests) {\n      openedRequest.abort();\n    }\n\n    this.openedRequests = [];\n  }\n\n  size() {\n    return this.openedRequests.length;\n  }\n\n}\n\nfunction pad(number) {\n  if (number < 10) {\n    return \"0\" + number;\n  }\n\n  return number;\n}\n\nfunction toLastModifiedString(date) {\n  return pad(date.getMonth() + 1) + \"/\" + pad(date.getDate()) + \"/\" + date.getFullYear() + \" \" + pad(date.getHours()) + \":\" + pad(date.getMinutes()) + \":\" + pad(date.getSeconds());\n}\n\nconst eventInterfaceTable = {\n  customevent: CustomEvent,\n  errorevent: ErrorEvent,\n  event: Event,\n  events: Event,\n  focusevent: FocusEvent,\n  hashchangeevent: HashChangeEvent,\n  htmlevents: Event,\n  keyboardevent: KeyboardEvent,\n  messageevent: MessageEvent,\n  mouseevent: MouseEvent,\n  mouseevents: MouseEvent,\n  popstateevent: PopStateEvent,\n  progressevent: ProgressEvent,\n  svgevents: Event,\n  touchevent: TouchEvent,\n  uievent: UIEvent,\n  uievents: UIEvent\n};\n\nclass DocumentImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._initGlobalEvents();\n\n    this._ownerDocument = this;\n    this.nodeType = NODE_TYPE.DOCUMENT_NODE;\n\n    if (!privateData.options) {\n      privateData.options = {};\n    }\n\n    if (!privateData.options.parsingMode) {\n      privateData.options.parsingMode = \"xml\";\n    }\n\n    if (!privateData.options.encoding) {\n      privateData.options.encoding = \"UTF-8\";\n    }\n\n    if (!privateData.options.contentType) {\n      privateData.options.contentType = privateData.options.parsingMode === \"xml\" ? \"application/xml\" : \"text/html\";\n    }\n\n    this._parsingMode = privateData.options.parsingMode;\n    this._htmlToDom = new HTMLToDOM(privateData.options.parsingMode);\n    this._implementation = DOMImplementation.createImpl([], {\n      ownerDocument: this\n    });\n    this._defaultView = privateData.options.defaultView || null;\n    this._global = privateData.options.global;\n    this._documentElement = null;\n    this._ids = Object.create(null);\n    this._attached = true;\n    this._currentScript = null;\n    this._cookieJar = privateData.options.cookieJar;\n    this._parseOptions = privateData.options.parseOptions;\n\n    if (this._cookieJar === undefined) {\n      this._cookieJar = new CookieJar(null, {\n        looseMode: true\n      });\n    }\n\n    this.contentType = privateData.options.contentType;\n    this._encoding = privateData.options.encoding;\n    const urlOption = privateData.options.url === undefined ? \"about:blank\" : privateData.options.url;\n    const parsed = whatwgURL.parseURL(urlOption);\n\n    if (parsed === null) {\n      throw new TypeError(\"Could not parse \\\"\".concat(urlOption, \"\\\" as a URL\"));\n    }\n\n    this._URL = parsed;\n    this.origin = whatwgURL.serializeURLOrigin(parsed);\n    this._location = Location.createImpl([], {\n      relevantDocument: this\n    });\n    this._history = History.createImpl([], {\n      window: this._defaultView,\n      document: this,\n      actAsIfLocationReloadCalled: () => this._location.reload()\n    });\n\n    if (privateData.options.cookie) {\n      const cookies = Array.isArray(privateData.options.cookie) ? privateData.options.cookie : [privateData.options.cookie];\n      const document = this;\n      cookies.forEach(cookieStr => {\n        document._cookieJar.setCookieSync(cookieStr, document.URL, {\n          ignoreError: true\n        });\n      });\n    }\n\n    this._workingNodeIterators = [];\n    this._workingNodeIteratorsMax = privateData.options.concurrentNodeIterators === undefined ? 10 : Number(privateData.options.concurrentNodeIterators);\n\n    if (isNaN(this._workingNodeIteratorsMax)) {\n      throw new TypeError(\"The 'concurrentNodeIterators' option must be a Number\");\n    }\n\n    if (this._workingNodeIteratorsMax < 0) {\n      throw new RangeError(\"The 'concurrentNodeIterators' option must be a non negative Number\");\n    }\n\n    this._referrer = privateData.options.referrer || \"\";\n    this._lastModified = toLastModifiedString(privateData.options.lastModified || new Date());\n    this._queue = new ResourceQueue(privateData.options.deferClose);\n    this._customResourceLoader = privateData.options.resourceLoader;\n    this._pool = privateData.options.pool;\n    this._agentOptions = privateData.options.agentOptions;\n    this._strictSSL = privateData.options.strictSSL;\n    this._proxy = privateData.options.proxy;\n    this._requestManager = new RequestManager();\n    this.readyState = \"loading\";\n    this._lastFocusedElement = null; // Each Document in a browsing context can also have a latest entry. This is the entry for that Document\n    // to which the browsing context's session history was most recently traversed. When a Document is created,\n    // it initially has no latest entry.\n\n    this._latestEntry = null;\n  }\n\n  get compatMode() {\n    return this._parsingMode === \"xml\" || this.doctype ? \"CSS1Compat\" : \"BackCompat\";\n  }\n\n  get charset() {\n    return this._encoding;\n  }\n\n  get characterSet() {\n    return this._encoding;\n  }\n\n  get inputEncoding() {\n    return this._encoding;\n  }\n\n  get doctype() {\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n        return childNode;\n      }\n    }\n\n    return null;\n  }\n\n  get URL() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n\n  get documentURI() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n\n  get location() {\n    return this._defaultView ? this._location : null;\n  }\n\n  get documentElement() {\n    if (this._documentElement) {\n      return this._documentElement;\n    }\n\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        this._documentElement = childNode;\n        return childNode;\n      }\n    }\n\n    return null;\n  }\n\n  get implementation() {\n    return this._implementation;\n  }\n\n  set implementation(implementation) {\n    this._implementation = implementation;\n  }\n\n  get defaultView() {\n    return this._defaultView;\n  }\n\n  get currentScript() {\n    return this._currentScript;\n  }\n\n  get activeElement() {\n    if (this._lastFocusedElement) {\n      return this._lastFocusedElement;\n    }\n\n    return this.body;\n  }\n\n  hasFocus() {\n    return Boolean(this._lastFocusedElement);\n  }\n\n  _createElementWithCorrectElementInterface(localName, namespace) {\n    // https://dom.spec.whatwg.org/#concept-element-interface\n    if (this._elementBuilders[namespace] && this._elementBuilders[namespace][localName]) {\n      return this._elementBuilders[namespace][localName](this, localName, namespace);\n    } else if (namespace === HTML_NS) {\n      return HTMLUnknownElement.createImpl([], {\n        ownerDocument: this,\n        localName,\n        namespace\n      });\n    } else if (namespace === SVG_NS) {\n      return SVGElement.createImpl([], {\n        ownerDocument: this,\n        localName,\n        namespace\n      });\n    }\n\n    return Element.createImpl([], {\n      ownerDocument: this,\n      localName,\n      namespace\n    });\n  }\n\n  appendChild(\n  /* Node */\n  arg) {\n    if (this.documentElement && arg.nodeType === NODE_TYPE.ELEMENT_NODE) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    return super.appendChild(arg);\n  }\n\n  removeChild(\n  /* Node */\n  arg) {\n    const ret = super.removeChild(arg);\n\n    if (arg === this._documentElement) {\n      this._documentElement = null; // force a recalculation\n    }\n\n    return ret;\n  }\n\n  _descendantRemoved(parent, child) {\n    if (child.tagName === \"STYLE\") {\n      const index = this.styleSheets.indexOf(child.sheet);\n\n      if (index > -1) {\n        this.styleSheets.splice(index, 1);\n      }\n    }\n  }\n\n  write() {\n    let text = \"\";\n\n    for (let i = 0; i < arguments.length; ++i) {\n      text += String(arguments[i]);\n    }\n\n    if (this._parsingMode === \"xml\") {\n      throw new DOMException(\"Cannot use document.write on XML documents\", \"InvalidStateError\");\n    }\n\n    if (this._writeAfterElement) {\n      // If called from an script element directly (during the first tick),\n      // the new elements are inserted right after that element.\n      const tempDiv = this.createElement(\"div\");\n      tempDiv.innerHTML = text;\n      let child = tempDiv.firstChild;\n      let previous = this._writeAfterElement;\n      const parent = this._writeAfterElement.parentNode;\n\n      while (child) {\n        const node = child;\n        child = child.nextSibling;\n        node._isMovingDueToDocumentWrite = true; // hack for script execution\n\n        parent.insertBefore(node, previous.nextSibling);\n        node._isMovingDueToDocumentWrite = false;\n        previous = node;\n      }\n    } else if (this.readyState === \"loading\") {\n      // During page loading, document.write appends to the current element\n      // Find the last child that has been added to the document.\n      if (this.lastChild) {\n        let node = this;\n\n        while (node.lastChild && node.lastChild.nodeType === NODE_TYPE.ELEMENT_NODE) {\n          node = node.lastChild;\n        }\n\n        node.innerHTML = text;\n      } else {\n        clearChildNodes(this);\n\n        this._htmlToDom.appendToDocument(text, this);\n      }\n    } else if (text) {\n      clearChildNodes(this);\n\n      this._htmlToDom.appendToDocument(text, this);\n    }\n  }\n\n  writeln() {\n    this.write(...arguments, \"\\n\");\n  } // This is implemented separately for Document (which has a _ids cache) and DocumentFragment (which does not).\n\n\n  getElementById(id) {\n    // Return the first element with this ID.\n    return this._ids[id] && this._ids[id].length > 0 ? this._ids[id][0] : null;\n  }\n\n  get referrer() {\n    return this._referrer || \"\";\n  }\n\n  get lastModified() {\n    return this._lastModified;\n  }\n\n  get images() {\n    return this.getElementsByTagName(\"IMG\");\n  }\n\n  get embeds() {\n    return this.getElementsByTagName(\"EMBED\");\n  }\n\n  get plugins() {\n    return this.embeds;\n  }\n\n  get links() {\n    return HTMLCollection.createImpl([], {\n      element: this,\n      query: () => domSymbolTree.treeToArray(this, {\n        filter: node => (node._localName === \"a\" || node._localName === \"area\") && node.hasAttribute(\"href\") && node._namespaceURI === HTML_NS\n      })\n    });\n  }\n\n  get forms() {\n    return this.getElementsByTagName(\"FORM\");\n  }\n\n  get scripts() {\n    return this.getElementsByTagName(\"SCRIPT\");\n  }\n\n  get anchors() {\n    return HTMLCollection.createImpl([], {\n      element: this,\n      query: () => domSymbolTree.treeToArray(this, {\n        filter: node => node._localName === \"a\" && node.hasAttribute(\"name\") && node._namespaceURI === HTML_NS\n      })\n    });\n  } // The applets attribute must return an\n  // HTMLCollection rooted at the Document node,\n  // whose filter matches nothing.\n  // (It exists for historical reasons.)\n\n\n  get applets() {\n    return HTMLCollection.createImpl([], {\n      element: this,\n      query: () => []\n    });\n  }\n\n  open() {\n    let child = domSymbolTree.firstChild(this);\n\n    while (child) {\n      this.removeChild(child);\n      child = domSymbolTree.firstChild(this);\n    }\n\n    this._documentElement = null;\n\n    this._modified();\n\n    return this;\n  }\n\n  close() {\n    this._queue.resume(); // Set the readyState to 'complete' once all resources are loaded.\n    // As a side-effect the document's load-event will be dispatched.\n\n\n    resourceLoader.enqueue(this, null, function () {\n      this.readyState = \"complete\";\n      const ev = this.createEvent(\"HTMLEvents\");\n      ev.initEvent(\"DOMContentLoaded\", false, false);\n      this.dispatchEvent(ev);\n    })(null, true);\n  }\n\n  getElementsByName(elementName) {\n    return NodeList.createImpl([], {\n      element: this,\n      query: () => domSymbolTree.treeToArray(this, {\n        filter: node => node.getAttribute && node.getAttribute(\"name\") === elementName\n      })\n    });\n  }\n\n  get title() {\n    // TODO SVG\n    const titleElement = firstDescendantWithHTMLLocalName(this, \"title\");\n    let value = titleElement !== null ? titleElement.textContent : \"\";\n    value = stripAndCollapseASCIIWhitespace(value);\n    return value;\n  }\n\n  set title(val) {\n    // TODO SVG\n    const titleElement = firstDescendantWithHTMLLocalName(this, \"title\");\n    const headElement = this.head;\n\n    if (titleElement === null && headElement === null) {\n      return;\n    }\n\n    let element;\n\n    if (titleElement !== null) {\n      element = titleElement;\n    } else {\n      element = this.createElement(\"title\");\n      headElement.appendChild(element);\n    }\n\n    element.textContent = val;\n  }\n\n  get dir() {\n    return this.documentElement ? this.documentElement.dir : \"\";\n  }\n\n  set dir(value) {\n    if (this.documentElement) {\n      this.documentElement.dir = value;\n    }\n  }\n\n  get head() {\n    return this.documentElement ? firstChildWithHTMLLocalName(this.documentElement, \"head\") : null;\n  }\n\n  get body() {\n    const documentElement = this.documentElement;\n\n    if (!documentElement || documentElement._localName !== \"html\" || documentElement._namespaceURI !== HTML_NS) {\n      return null;\n    }\n\n    return firstChildWithHTMLLocalNames(this.documentElement, new Set([\"body\", \"frameset\"]));\n  }\n\n  set body(value) {\n    if (value === null || value._namespaceURI !== HTML_NS || value._localName !== \"body\" && value._localName !== \"frameset\") {\n      throw new DOMException(\"Cannot set the body to null or a non-body/frameset element\", \"HierarchyRequestError\");\n    }\n\n    const bodyElement = this.body;\n\n    if (value === bodyElement) {\n      return;\n    }\n\n    if (bodyElement !== null) {\n      bodyElement.parentNode.replaceChild(value, bodyElement);\n      return;\n    }\n\n    const documentElement = this.documentElement;\n\n    if (documentElement === null) {\n      throw new DOMException(\"Cannot set the body when there is no document element\", \"HierarchyRequestError\");\n    }\n\n    documentElement.appendChild(value);\n  }\n\n  _runPreRemovingSteps(oldNode) {\n    for (const activeNodeIterator of this._workingNodeIterators) {\n      activeNodeIterator._preRemovingSteps(oldNode);\n    }\n  }\n\n  createEvent(type) {\n    const typeLower = type.toLowerCase();\n    const eventWrapper = eventInterfaceTable[typeLower] || null;\n\n    if (!eventWrapper) {\n      throw new DOMException(\"The provided event type (\\\"\" + type + \"\\\") is invalid\", \"NotSupportedError\");\n    }\n\n    const impl = eventWrapper.createImpl([\"\"]);\n    impl._initializedFlag = false;\n    return impl;\n  }\n\n  createProcessingInstruction(target, data) {\n    validateName(target);\n\n    if (data.includes(\"?>\")) {\n      throw new DOMException(\"Processing instruction data cannot contain the string \\\"?>\\\"\", \"InvalidCharacterError\");\n    }\n\n    return ProcessingInstruction.createImpl([], {\n      ownerDocument: this,\n      target,\n      data\n    });\n  } // https://dom.spec.whatwg.org/#dom-document-createcdatasection\n\n\n  createCDATASection(data) {\n    if (this._parsingMode === \"html\") {\n      throw new DOMException(\"Cannot create CDATA sections in HTML documents\", \"NotSupportedError\");\n    }\n\n    if (data.includes(\"]]>\")) {\n      throw new DOMException(\"CDATA section data cannot contain the string \\\"]]>\\\"\", \"InvalidCharacterError\");\n    }\n\n    return CDATASection.createImpl([], {\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createTextNode(data) {\n    return Text.createImpl([], {\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createComment(data) {\n    return Comment.createImpl([], {\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createElement(localName) {\n    validateName(localName);\n\n    if (this._parsingMode === \"html\") {\n      localName = asciiLowercase(localName);\n    }\n\n    const namespace = this._parsingMode === \"html\" || this.contentType === \"application/xhtml+xml\" ? HTML_NS : null;\n    return this._createElementWithCorrectElementInterface(localName, namespace);\n  }\n\n  createElementNS(namespace, qualifiedName) {\n    namespace = namespace !== null ? String(namespace) : namespace;\n    const extracted = validateAndExtract(namespace, qualifiedName);\n\n    const element = this._createElementWithCorrectElementInterface(extracted.localName, extracted.namespace);\n\n    element._prefix = extracted.prefix;\n    return element;\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], {\n      ownerDocument: this\n    });\n  }\n\n  createAttribute(localName) {\n    validateName(localName);\n\n    if (this._parsingMode === \"html\") {\n      localName = asciiLowercase(localName);\n    }\n\n    return generatedAttr.createImpl([], {\n      localName\n    });\n  }\n\n  createAttributeNS(namespace, name) {\n    if (namespace === undefined) {\n      namespace = null;\n    }\n\n    namespace = namespace !== null ? String(namespace) : namespace;\n    const extracted = validateAndExtract(namespace, name);\n    return generatedAttr.createImpl([], {\n      namespace: extracted.namespace,\n      namespacePrefix: extracted.prefix,\n      localName: extracted.localName\n    });\n  } // TODO: Add callback interface support to `webidl2js`\n\n\n  createTreeWalker(root, whatToShow, filter) {\n    return TreeWalker.createImpl([], {\n      root,\n      whatToShow,\n      filter\n    });\n  }\n\n  createNodeIterator(root, whatToShow, filter) {\n    const nodeIterator = NodeIterator.createImpl([], {\n      root,\n      whatToShow,\n      filter\n    });\n\n    this._workingNodeIterators.push(nodeIterator);\n\n    while (this._workingNodeIterators.length > this._workingNodeIteratorsMax) {\n      const toInactivate = this._workingNodeIterators.shift();\n\n      toInactivate._working = false;\n    }\n\n    return nodeIterator;\n  }\n\n  importNode(node, deep) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(\"Cannot import a document node\", \"NotSupportedError\");\n    }\n\n    return clone(node, this, deep);\n  }\n\n  adoptNode(node) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(\"Cannot adopt a document node\", \"NotSupportedError\");\n    } // TODO: Determine correct way to detect a shadow root\n    // See also https://github.com/w3c/webcomponents/issues/182\n\n\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n\n    node._ownerDocument = this;\n\n    for (const descendant of domSymbolTree.treeIterator(node)) {\n      descendant._ownerDocument = this;\n    }\n\n    return node;\n  }\n\n  get cookie() {\n    return this._cookieJar.getCookieStringSync(this.URL, {\n      http: false\n    });\n  }\n\n  set cookie(cookieStr) {\n    cookieStr = String(cookieStr);\n\n    this._cookieJar.setCookieSync(cookieStr, this.URL, {\n      http: false,\n      ignoreError: true\n    });\n  } // The clear(), captureEvents(), and releaseEvents() methods must do nothing\n\n\n  clear() {}\n\n  captureEvents() {}\n\n  releaseEvents() {}\n\n  get styleSheets() {\n    if (!this._styleSheets) {\n      this._styleSheets = new StyleSheetList();\n    } // TODO: each style and link element should register its sheet on creation\n    // and remove it on removal.\n\n\n    return this._styleSheets;\n  }\n\n  get hidden() {\n    if (this._defaultView && this._defaultView._pretendToBeVisual) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get visibilityState() {\n    if (this._defaultView && this._defaultView._pretendToBeVisual) {\n      return \"visible\";\n    }\n\n    return \"prerender\";\n  }\n\n}\n\neventAccessors.createEventAccessor(DocumentImpl.prototype, \"readystatechange\");\nmixin(DocumentImpl.prototype, GlobalEventHandlersImpl.prototype);\nmixin(DocumentImpl.prototype, NonElementParentNodeImpl.prototype);\nmixin(DocumentImpl.prototype, ParentNodeImpl.prototype);\nDocumentImpl.prototype._elementBuilders = Object.create(null);\nDocumentImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\nDocumentImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\nDocumentImpl.prototype.getElementsByClassName = memoizeQuery(function getElementsByClassName(classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\nmodule.exports = {\n  implementation: DocumentImpl\n};","map":null,"metadata":{},"sourceType":"script"}