{"ast":null,"code":"\"use strict\";\n\nconst util = require(\"util\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\n\nconst errorReportingMode = Symbol(\"error reporting mode\"); // https://html.spec.whatwg.org/multipage/webappapis.html#report-the-error\n// Omits script parameter and any check for muted errors.\n// Takes target as an EventTarget impl.\n// Takes error object, message, and location as params, unlike the spec.\n// Returns whether the event was handled or not.\n\nfunction reportAnError(line, col, target, errorObject, message, location) {\n  if (target[errorReportingMode]) {\n    return false;\n  }\n\n  target[errorReportingMode] = true; // TODO Events: use constructor directly, once they are no longer tied to a window.\n\n  const event = ErrorEvent.createImpl([\"error\", {\n    bubbles: false,\n    cancelable: true,\n    message,\n    filename: location,\n    lineno: line,\n    colno: col,\n    error: errorObject\n  }]);\n\n  try {\n    target.dispatchEvent(event);\n  } finally {\n    target[errorReportingMode] = false;\n    return event.defaultPrevented;\n  }\n}\n\nmodule.exports = function reportException(window, error, filenameHint) {\n  // This function will give good results on real Error objects with stacks; poor ones otherwise\n  const stack = error && error.stack;\n  const lines = stack && stack.split(\"\\n\"); // Find the first line that matches; important for multi-line messages\n\n  let pieces;\n\n  if (lines) {\n    for (let i = 1; i < lines.length && !pieces; ++i) {\n      pieces = lines[i].match(/at (?:(.+)\\s+)?\\(?(?:(.+?):(\\d+):(\\d+)|([^)]+))\\)?/);\n    }\n  }\n\n  const fileName = pieces && pieces[2] || filenameHint || window._document.URL;\n  const lineNumber = pieces && parseInt(pieces[3]) || 0;\n  const columnNumber = pieces && parseInt(pieces[4]) || 0;\n  const windowImpl = idlUtils.implForWrapper(window);\n  const handled = reportAnError(lineNumber, columnNumber, windowImpl, error, error.message, fileName);\n\n  if (!handled) {\n    const errorString = shouldBeDisplayedAsError(error) ? \"[\".concat(error.name, \": \").concat(error.message, \"]\") : util.inspect(error);\n    const jsdomError = new Error(\"Uncaught \".concat(errorString));\n    jsdomError.detail = error;\n    jsdomError.type = \"unhandled exception\";\n\n    window._virtualConsole.emit(\"jsdomError\", jsdomError);\n  }\n};\n\nfunction shouldBeDisplayedAsError(x) {\n  return x.name && x.message !== undefined && x.stack;\n}","map":null,"metadata":{},"sourceType":"script"}