{"ast":null,"code":"\"use strict\";\n\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst _require = require(\"whatwg-url\"),\n      parseURL = _require.parseURL,\n      serializeURL = _require.serializeURL;\n\nconst _require2 = require(\"../window/navigation\"),\n      evaluateJavaScriptURL = _require2.evaluateJavaScriptURL;\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nconst _require3 = require(\"../../browser/documentfeatures\"),\n      applyDocumentFeatures = _require3.applyDocumentFeatures;\n\nconst resourceLoader = require(\"../../browser/resource-loader\");\n\nconst _require4 = require(\"../../utils\"),\n      defineGetter = _require4.defineGetter,\n      reflectURLAttribute = _require4.reflectURLAttribute;\n\nconst _require5 = require(\"../helpers/document-base-url\"),\n      documentBaseURL = _require5.documentBaseURL;\n\nconst _require6 = require(\"../attributes\"),\n      getAttributeValue = _require6.getAttributeValue;\n\nconst idlUtils = require(\"../generated/utils\");\n\nfunction loadFrame(frame) {\n  if (frame._contentDocument) {\n    if (frame._contentDocument._defaultView) {\n      // close calls delete on its document.\n      frame._contentDocument._defaultView.close();\n    } else {\n      delete frame._contentDocument;\n    }\n  }\n\n  const parentDoc = frame._ownerDocument; // https://html.spec.whatwg.org/#process-the-iframe-attributes\n\n  let url;\n  const srcAttribute = getAttributeValue(frame, \"src\");\n\n  if (srcAttribute === \"\") {\n    url = parseURL(\"about:blank\");\n  } else {\n    url = parseURL(srcAttribute, {\n      baseURL: documentBaseURL(parentDoc) || undefined\n    }) || parseURL(\"about:blank\");\n  }\n\n  const serializedURL = serializeURL(url); // This is not great, but prevents a require cycle during webidl2js generation\n\n  const wnd = new parentDoc._defaultView.constructor({\n    parsingMode: \"html\",\n    url: url.scheme === \"javascript\" || serializedURL === \"about:blank\" ? parentDoc.URL : serializedURL,\n    resourceLoader: parentDoc._customResourceLoader,\n    userAgent: parentDoc._defaultView.navigator.userAgent,\n    referrer: parentDoc.URL,\n    cookieJar: parentDoc._cookieJar,\n    pool: parentDoc._pool,\n    encoding: parentDoc._encoding,\n    agentOptions: parentDoc._agentOptions,\n    strictSSL: parentDoc._strictSSL,\n    proxy: parentDoc._proxy,\n    runScripts: parentDoc._defaultView._runScripts,\n    commonForOrigin: parentDoc._defaultView._commonForOrigin\n  });\n  const contentDoc = frame._contentDocument = idlUtils.implForWrapper(wnd._document);\n  applyDocumentFeatures(contentDoc, parentDoc._implementation._features);\n  const parent = parentDoc._defaultView;\n  const contentWindow = contentDoc._defaultView;\n  contentWindow._parent = parent;\n  contentWindow._top = parent.top;\n  contentWindow._frameElement = frame;\n  contentWindow._virtualConsole = parent._virtualConsole;\n\n  if (parentDoc.origin === contentDoc.origin) {\n    contentWindow._currentOriginData.windowsInSameOrigin.push(contentWindow);\n  } // Handle about:blank with a simulated load of an empty document.\n\n\n  if (serializedURL === \"about:blank\") {\n    // Cannot be done inside the enqueued callback; the documentElement etc. need to be immediately available.\n    contentDoc.write(\"<html><head></head><body></body></html>\");\n    contentDoc.close();\n    resourceLoader.enqueue(frame)(); // to fire the load event\n  } else if (url.scheme === \"javascript\") {\n    // Cannot be done inside the enqueued callback; the documentElement etc. need to be immediately available.\n    contentDoc.write(\"<html><head></head><body></body></html>\");\n    contentDoc.close();\n    const result = evaluateJavaScriptURL(contentWindow, url);\n\n    if (typeof result === \"string\") {\n      contentDoc.body.textContent = result;\n    }\n\n    resourceLoader.enqueue(frame)(); // to fire the load event\n  } else {\n    resourceLoader.load(frame, serializedURL, {\n      defaultEncoding: parentDoc._encoding,\n      detectMetaCharset: true\n    }, (html, responseURL, response) => {\n      if (response) {\n        const contentType = MIMEType.parse(response.headers[\"content-type\"]);\n\n        if (contentType) {\n          if (contentType.isXML()) {\n            contentDoc._parsingMode = \"xml\";\n          }\n\n          contentDoc.contentType = contentType.essence;\n          contentDoc._encoding = contentType.parameters.get(\"charset\");\n        }\n      }\n\n      contentDoc.write(html);\n      contentDoc.close();\n    });\n  }\n}\n\nfunction refreshAccessors(document) {\n  const window = document._defaultView;\n\n  if (!window) {\n    return;\n  }\n\n  const frames = document.querySelectorAll(\"iframe,frame\"); // delete accessors for all frames\n\n  for (let i = 0; i < window._length; ++i) {\n    delete window[i];\n  }\n\n  window._length = frames.length;\n  Array.prototype.forEach.call(frames, (frame, i) => {\n    defineGetter(window, i, () => frame.contentWindow);\n  });\n}\n\nclass HTMLFrameElementImpl extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n    this._contentDocument = null;\n  }\n\n  _attrModified(name, value, oldVal) {\n    super._attrModified(name, value, oldVal);\n\n    if (name === \"src\") {\n      // iframe should never load in a document without a Window\n      // (e.g. implementation.createHTMLDocument)\n      if (this._attached && this._ownerDocument._defaultView) {\n        loadFrame(this);\n      }\n    }\n  }\n\n  _detach() {\n    super._detach();\n\n    if (this.contentWindow) {\n      this.contentWindow.close();\n    }\n\n    refreshAccessors(this._ownerDocument);\n  }\n\n  _attach() {\n    super._attach();\n\n    if (this._ownerDocument._defaultView) {\n      loadFrame(this);\n    }\n\n    refreshAccessors(this._ownerDocument);\n  }\n\n  get contentDocument() {\n    return this._contentDocument;\n  }\n\n  get contentWindow() {\n    return this.contentDocument ? this.contentDocument._defaultView : null;\n  }\n\n  get src() {\n    return reflectURLAttribute(this, \"src\");\n  }\n\n  set src(value) {\n    this.setAttribute(\"src\", value);\n  }\n\n  get longDesc() {\n    return reflectURLAttribute(this, \"longdesc\");\n  }\n\n  set longDesc(value) {\n    this.setAttribute(\"longdesc\", value);\n  }\n\n}\n\nmodule.exports = {\n  implementation: HTMLFrameElementImpl\n};","map":null,"metadata":{},"sourceType":"script"}