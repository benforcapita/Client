{"ast":null,"code":"\"use strict\";\n\nconst vm = require(\"vm\");\n\nconst conversions = require(\"webidl-conversions\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\n\nconst reportException = require(\"./runtime-script-errors\");\n\nexports.appendHandler = function appendHandler(el, eventName) {\n  el.addEventListener(eventName, event => {\n    // https://html.spec.whatwg.org/#the-event-handler-processing-algorithm\n    event = idlUtils.implForWrapper(event);\n    const callback = el[\"on\" + eventName];\n\n    if (callback === null) {\n      return;\n    }\n\n    const specialError = ErrorEvent.isImpl(event) && event.type === \"error\" && event.currentTarget.constructor.name === \"Window\";\n    let returnValue = null;\n    const thisValue = idlUtils.tryWrapperForImpl(event.currentTarget); // https://heycam.github.io/webidl/#es-invoking-callback-functions\n\n    if (typeof callback === \"function\") {\n      if (specialError) {\n        returnValue = callback.call(thisValue, event.message, event.filename, event.lineno, event.colno, event.error);\n      } else {\n        const eventWrapper = idlUtils.wrapperForImpl(event);\n        returnValue = callback.call(thisValue, eventWrapper);\n      }\n    }\n\n    if (event.type === \"beforeunload\") {\n      // TODO: we don't implement BeforeUnloadEvent so we can't brand-check here\n      // Perform conversion which in the spec is done by the event handler return type being DOMString?\n      returnValue = returnValue === undefined || returnValue === null ? null : conversions.DOMString(returnValue);\n\n      if (returnValue !== null) {\n        event._canceledFlag = true;\n\n        if (event.returnValue === \"\") {\n          event.returnValue = returnValue;\n        }\n      }\n    } else if (specialError) {\n      if (returnValue === true) {\n        event._canceledFlag = true;\n      }\n    } else if (returnValue === false) {\n      event._canceledFlag = true;\n    }\n  });\n}; // \"Simple\" in this case means \"no content attributes involved\"\n\n\nexports.setupForSimpleEventAccessors = (prototype, events) => {\n  prototype._getEventHandlerFor = function (event) {\n    return this._eventHandlers ? this._eventHandlers[event] : undefined;\n  };\n\n  prototype._setEventHandlerFor = function (event, handler) {\n    if (!this._registeredHandlers) {\n      this._registeredHandlers = new Set();\n      this._eventHandlers = Object.create(null);\n    }\n\n    if (!this._registeredHandlers.has(event) && handler !== null) {\n      this._registeredHandlers.add(event);\n\n      exports.appendHandler(this, event);\n    }\n\n    this._eventHandlers[event] = handler;\n  };\n\n  for (const event of events) {\n    exports.createEventAccessor(prototype, event);\n  }\n}; // https://html.spec.whatwg.org/#event-handler-idl-attributes\n\n\nexports.createEventAccessor = function createEventAccessor(obj, event) {\n  Object.defineProperty(obj, \"on\" + event, {\n    configurable: true,\n    enumerable: true,\n\n    get() {\n      // https://html.spec.whatwg.org/#getting-the-current-value-of-the-event-handler\n      const value = this._getEventHandlerFor(event);\n\n      if (!value) {\n        return null;\n      }\n\n      if (value.body !== undefined) {\n        let element;\n        let document;\n\n        if (this.constructor.name === \"Window\") {\n          element = null;\n          document = idlUtils.implForWrapper(this.document);\n        } else {\n          element = this;\n          document = element.ownerDocument;\n        }\n\n        const body = value.body;\n        const formOwner = element !== null && element.form ? element.form : null;\n        const window = this.constructor.name === \"Window\" && this._document ? this : document.defaultView;\n\n        try {\n          // eslint-disable-next-line no-new-func\n          Function(body); // properly error out on syntax errors\n          // Note: this won't execute body; that would require `Function(body)()`.\n        } catch (e) {\n          if (window) {\n            reportException(window, e);\n          }\n\n          this._setEventHandlerFor(event, null);\n\n          return null;\n        } // Note: the with (window) { } is not necessary in Node, but is necessary in a browserified environment.\n\n\n        let fn;\n        const createFunction = vm.isContext(document._global) ? document.defaultView._globalProxy.Function : Function;\n\n        if (event === \"error\" && element === null) {\n          const wrapperBody = document ? body + \"\\n//# sourceURL=\".concat(document.URL) : body; // eslint-disable-next-line no-new-func\n\n          fn = createFunction(\"window\", \"with (window) { return function onerror(event, source, lineno, colno, error) {\\n  \".concat(wrapperBody, \"\\n}; }\"))(window);\n        } else {\n          const argNames = [];\n          const args = [];\n          argNames.push(\"window\");\n          args.push(window);\n\n          if (element !== null) {\n            argNames.push(\"document\");\n            args.push(idlUtils.wrapperForImpl(document));\n          }\n\n          if (formOwner !== null) {\n            argNames.push(\"formOwner\");\n            args.push(idlUtils.wrapperForImpl(formOwner));\n          }\n\n          if (element !== null) {\n            argNames.push(\"element\");\n            args.push(idlUtils.wrapperForImpl(element));\n          }\n\n          let wrapperBody = \"\\nreturn function on\".concat(event, \"(event) {\\n  \").concat(body, \"\\n};\");\n\n          for (let i = argNames.length - 1; i >= 0; --i) {\n            wrapperBody = \"with (\".concat(argNames[i], \") { \").concat(wrapperBody, \" }\");\n          }\n\n          if (document) {\n            wrapperBody += \"\\n//# sourceURL=\".concat(document.URL);\n          }\n\n          argNames.push(wrapperBody);\n          fn = createFunction(...argNames)(...args);\n        }\n\n        this._setEventHandlerFor(event, fn);\n      }\n\n      return this._getEventHandlerFor(event);\n    },\n\n    set(val) {\n      val = eventHandlerArgCoercion(val);\n\n      this._setEventHandlerFor(event, val);\n    }\n\n  });\n};\n\nfunction typeIsObject(v) {\n  return typeof v === \"object\" && v !== null || typeof v === \"function\";\n} // Implements:\n//     [TreatNonObjectAsNull]\n//     callback EventHandlerNonNull = any (Event event);\n//     typedef EventHandlerNonNull? EventHandler;\n// Also implements the part of https://heycam.github.io/webidl/#es-invoking-callback-functions which treats\n// non-callable callback functions as callback functions that return undefined.\n// TODO: replace with webidl2js typechecking when it has sufficient callback support\n\n\nfunction eventHandlerArgCoercion(val) {\n  if (!typeIsObject(val)) {\n    return null;\n  }\n\n  return val;\n}","map":null,"metadata":{},"sourceType":"script"}