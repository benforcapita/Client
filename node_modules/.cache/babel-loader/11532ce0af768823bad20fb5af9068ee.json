{"ast":null,"code":"\"use strict\";\n\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst parseDataURL = require(\"data-urls\");\n\nconst sniffHTMLEncoding = require(\"html-encoding-sniffer\");\n\nconst whatwgEncoding = require(\"whatwg-encoding\");\n\nconst fs = require(\"fs\");\n\nconst request = require(\"request\");\n\nconst _require = require(\"../living/helpers/document-base-url\"),\n      documentBaseURLSerialized = _require.documentBaseURLSerialized;\n\nconst NODE_TYPE = require(\"../living/node-type\");\n/* eslint-disable no-restricted-modules */\n// TODO: stop using the built-in URL in favor of the spec-compliant whatwg-url package\n// This legacy usage is in the process of being purged.\n\n\nconst URL = require(\"url\");\n/* eslint-enable no-restricted-modules */\n\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nfunction createResourceLoadHandler(element, resourceUrl, document, loadCallback) {\n  if (loadCallback === undefined) {\n    loadCallback = () => {// do nothing\n    };\n  }\n\n  return (err, data, response) => {\n    const ev = document.createEvent(\"HTMLEvents\");\n\n    if (!err) {\n      try {\n        loadCallback.call(element, data, resourceUrl, response);\n        ev.initEvent(\"load\", false, false);\n      } catch (e) {\n        err = e;\n      }\n    }\n\n    if (err) {\n      if (!err.isAbortError) {\n        ev.initEvent(\"error\", false, false);\n        ev.error = err;\n        element.dispatchEvent(ev);\n        const error = new Error(\"Could not load \".concat(element.localName, \": \\\"\").concat(resourceUrl, \"\\\"\"));\n        error.detail = err;\n        error.type = \"resource loading\";\n\n        document._defaultView._virtualConsole.emit(\"jsdomError\", error);\n      }\n    } else {\n      element.dispatchEvent(ev);\n    }\n  };\n}\n\nexports.readFile = function (filePath, {\n  defaultEncoding,\n  detectMetaCharset\n}, callback) {\n  const readableStream = fs.createReadStream(filePath);\n  let data = Buffer.alloc(0);\n  readableStream.on(\"error\", callback);\n  readableStream.on(\"data\", chunk => {\n    data = Buffer.concat([data, chunk]);\n  });\n  readableStream.on(\"end\", () => {\n    // Not passing default encoding means binary\n    if (defaultEncoding) {\n      const encoding = detectMetaCharset ? sniffHTMLEncoding(data, {\n        defaultEncoding\n      }) : whatwgEncoding.getBOMEncoding(data) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(data, encoding);\n      callback(null, decoded, {\n        headers: {\n          \"content-type\": \"text/plain;charset=\" + encoding\n        }\n      });\n    } else {\n      callback(null, data);\n    }\n  });\n  return {\n    abort() {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n\n  };\n};\n\nfunction readDataURL(dataURL, {\n  defaultEncoding,\n  detectMetaCharset\n}, callback) {\n  try {\n    const parsed = parseDataURL(dataURL); // If default encoding does not exist, pass on binary data.\n\n    if (defaultEncoding) {\n      const sniffOptions = {\n        transportLayerEncodingLabel: parsed.mimeType.parameters.get(\"charset\"),\n        defaultEncoding\n      };\n      const encoding = detectMetaCharset ? sniffHTMLEncoding(parsed.body, sniffOptions) : whatwgEncoding.getBOMEncoding(parsed.body) || whatwgEncoding.labelToName(parsed.mimeType.parameters.get(\"charset\")) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(parsed.body, encoding);\n      parsed.mimeType.parameters.set(\"charset\", encoding);\n      callback(null, decoded, {\n        headers: {\n          \"content-type\": parsed.mimeType.toString()\n        }\n      });\n    } else {\n      callback(null, parsed.body, {\n        headers: {\n          \"content-type\": parsed.mimeType.toString()\n        }\n      });\n    }\n  } catch (err) {\n    callback(err, null);\n  }\n\n  return null;\n} // NOTE: request wraps tough-cookie cookie jar\n// (see: https://github.com/request/request/blob/master/lib/cookies.js).\n// Therefore, to pass our cookie jar to the request, we need to create\n// request's wrapper and monkey patch it with our jar.\n\n\nexports.wrapCookieJarForRequest = cookieJar => {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n};\n\nfunction fetch(urlObj, options, callback) {\n  if (urlObj.protocol === \"data:\") {\n    return readDataURL(urlObj.href, options, callback);\n  } else if (urlObj.hostname) {\n    return exports.download(urlObj, options, callback);\n  }\n\n  const filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n  return exports.readFile(filePath, options, callback);\n}\n\nexports.enqueue = function (element, resourceUrl, callback) {\n  const document = element.nodeType === NODE_TYPE.DOCUMENT_NODE ? element : element._ownerDocument;\n\n  if (document._queue) {\n    const loadHandler = createResourceLoadHandler(element, resourceUrl || document.URL, document, callback);\n    return document._queue.push(loadHandler);\n  }\n\n  return () => {// do nothing in queue-less documents\n  };\n};\n\nexports.download = function (url, options, callback) {\n  const requestOptions = {\n    pool: options.pool,\n    agent: options.agent,\n    agentOptions: options.agentOptions,\n    agentClass: options.agentClass,\n    strictSSL: options.strictSSL,\n    gzip: true,\n    jar: exports.wrapCookieJarForRequest(options.cookieJar),\n    encoding: null,\n    headers: {\n      \"User-Agent\": options.userAgent,\n      \"Accept-Language\": \"en\",\n      Accept: options.accept || \"*/*\"\n    }\n  };\n\n  if (options.referrer && !IS_BROWSER) {\n    requestOptions.headers.referer = options.referrer;\n  }\n\n  if (options.proxy) {\n    requestOptions.proxy = options.proxy;\n  }\n\n  Object.assign(requestOptions.headers, options.headers);\n  const defaultEncoding = options.defaultEncoding,\n        detectMetaCharset = options.detectMetaCharset;\n  const req = request(url, requestOptions, (error, response, bufferData) => {\n    if (!error) {\n      // If default encoding does not exist, pass on binary data.\n      if (defaultEncoding) {\n        const contentType = MIMEType.parse(response.headers[\"content-type\"]) || new MIMEType(\"text/plain\");\n        const sniffOptions = {\n          transportLayerEncodingLabel: contentType.parameters.get(\"charset\"),\n          defaultEncoding\n        };\n        const encoding = detectMetaCharset ? sniffHTMLEncoding(bufferData, sniffOptions) : whatwgEncoding.getBOMEncoding(bufferData) || whatwgEncoding.labelToName(contentType.parameters.get(\"charset\")) || defaultEncoding;\n        const decoded = whatwgEncoding.decode(bufferData, encoding);\n        contentType.parameters.set(\"charset\", encoding);\n        response.headers[\"content-type\"] = contentType.toString();\n        callback(null, decoded, response);\n      } else {\n        callback(null, bufferData, response);\n      }\n    } else {\n      callback(error, null, response);\n    }\n  });\n  return {\n    abort() {\n      req.abort();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n\n  };\n};\n\nexports.load = function (element, urlString, options, callback) {\n  const document = element._ownerDocument;\n  const documentImpl = document.implementation;\n\n  if (!documentImpl._hasFeature(\"FetchExternalResources\", element.tagName.toLowerCase())) {\n    return;\n  }\n\n  if (documentImpl._hasFeature(\"SkipExternalResources\", urlString)) {\n    return;\n  }\n\n  const urlObj = URL.parse(urlString);\n  const enqueued = exports.enqueue(element, urlString, callback);\n  const customLoader = document._customResourceLoader;\n  const requestManager = document._requestManager;\n  const cookieJar = document._cookieJar;\n  options.accept = element._accept;\n  options.cookieJar = cookieJar;\n  options.referrer = document.URL;\n  options.pool = document._pool;\n  options.agentOptions = document._agentOptions;\n  options.strictSSL = document._strictSSL;\n  options.proxy = document._proxy;\n  options.userAgent = document._defaultView.navigator.userAgent;\n  let req = null;\n\n  function wrappedEnqueued() {\n    if (req && requestManager) {\n      requestManager.remove(req);\n    } // do not trigger if the window is closed\n\n\n    if (element._ownerDocument && element._ownerDocument.defaultView.document) {\n      enqueued.apply(this, arguments);\n    }\n  }\n\n  if (typeof customLoader === \"function\") {\n    req = customLoader({\n      element,\n      url: urlObj,\n      cookie: cookieJar.getCookieStringSync(urlObj, {\n        http: true\n      }),\n      baseUrl: documentBaseURLSerialized(document),\n\n      defaultFetch(fetchCallback) {\n        return fetch(urlObj, options, fetchCallback);\n      }\n\n    }, wrappedEnqueued);\n  } else {\n    req = fetch(urlObj, options, wrappedEnqueued);\n  }\n\n  if (req && requestManager) {\n    requestManager.add(req);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}