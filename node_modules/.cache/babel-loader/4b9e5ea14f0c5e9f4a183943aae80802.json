{"ast":null,"code":"\"use strict\"; // Actual implementation of the Performance class.\n\nconst clockIsAccurate = require(\"./clock-is-accurate\");\n\nconst calculateClockOffset = require(\"./calculate-clock-offset\");\n\nconst _require = require(\"./utils\"),\n      hrtime = _require.hrtime,\n      toMS = _require.toMS;\n\nconst kTimeOrigin = Symbol(\"time origin\");\nconst kTimeOriginTimestamp = Symbol(\"time origin timestamp\");\n\nclass Performance {\n  constructor() {\n    // Time origin.\n    const timeOrigin = hrtime();\n    this[kTimeOrigin] = timeOrigin;\n\n    if (clockIsAccurate) {\n      // Let |t1| be the DOMHighResTimeStamp representing the high resolution Unix time at which the global monotonic\n      // clock is zero. This has to be calculated for every Performance object to account for clock drifts.\n      const t1 = calculateClockOffset(); // Let |t2| be the DOMHighResTimeStamp representing the high resolution time value of the global monotonic clock\n      // at global's time origin.\n\n      const t2 = toMS(timeOrigin); // Return the sum of |t1| and |t2|.\n\n      this[kTimeOriginTimestamp] = t1 + t2;\n    } else {\n      // Clock isn't accurate enough. Use millisecond accuracy per spec.\n      const cur = Date.now();\n      this[kTimeOriginTimestamp] = cur;\n    }\n  } // The timeOrigin getter actually returns the time origin timestamp, not the raw time origin.\n\n\n  get timeOrigin() {\n    return this[kTimeOriginTimestamp];\n  }\n\n  now() {\n    const diff = toMS(hrtime(this[kTimeOrigin]));\n    return clockIsAccurate ? diff : Math.round(diff);\n  }\n\n  toJSON() {\n    return {\n      timeOrigin: this.timeOrigin\n    };\n  }\n\n}\n\nmodule.exports = {\n  Performance\n};","map":null,"metadata":{},"sourceType":"script"}