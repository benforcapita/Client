{"ast":null,"code":"\"use strict\";\n\nconst parse = require(\"./parser.js\");\n\nconst serialize = require(\"./serializer.js\");\n\nconst _require = require(\"./utils.js\"),\n      asciiLowercase = _require.asciiLowercase,\n      solelyContainsHTTPTokenCodePoints = _require.solelyContainsHTTPTokenCodePoints,\n      soleyContainsHTTPQuotedStringTokenCodePoints = _require.soleyContainsHTTPQuotedStringTokenCodePoints;\n\nmodule.exports = class MIMEType {\n  constructor(string) {\n    string = String(string);\n    const result = parse(string);\n\n    if (result === null) {\n      throw new Error(\"Could not parse MIME type string \\\"\".concat(string, \"\\\"\"));\n    }\n\n    this._type = result.type;\n    this._subtype = result.subtype;\n    this._parameters = new MIMETypeParameters(result.parameters);\n  }\n\n  static parse(string) {\n    try {\n      return new this(string);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  get essence() {\n    return \"\".concat(this.type, \"/\").concat(this.subtype);\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(value) {\n    value = asciiLowercase(String(value));\n\n    if (value.length === 0) {\n      throw new Error(\"Invalid type: must be a non-empty string\");\n    }\n\n    if (!solelyContainsHTTPTokenCodePoints(value)) {\n      throw new Error(\"Invalid type \".concat(value, \": must contain only HTTP token code points\"));\n    }\n\n    this._type = value;\n  }\n\n  get subtype() {\n    return this._subtype;\n  }\n\n  set subtype(value) {\n    value = asciiLowercase(String(value));\n\n    if (value.length === 0) {\n      throw new Error(\"Invalid subtype: must be a non-empty string\");\n    }\n\n    if (!solelyContainsHTTPTokenCodePoints(value)) {\n      throw new Error(\"Invalid subtype \".concat(value, \": must contain only HTTP token code points\"));\n    }\n\n    this._subtype = value;\n  }\n\n  get parameters() {\n    return this._parameters;\n  }\n\n  toString() {\n    // The serialize function works on both \"MIME type records\" (i.e. the results of parse) and on this class, since\n    // this class's interface is identical.\n    return serialize(this);\n  }\n\n  isJavaScript({\n    allowParameters = false\n  } = {}) {\n    switch (this._type) {\n      case \"text\":\n        {\n          switch (this._subtype) {\n            case \"ecmascript\":\n            case \"javascript\":\n            case \"javascript1.0\":\n            case \"javascript1.1\":\n            case \"javascript1.2\":\n            case \"javascript1.3\":\n            case \"javascript1.4\":\n            case \"javascript1.5\":\n            case \"jscript\":\n            case \"livescript\":\n            case \"x-ecmascript\":\n            case \"x-javascript\":\n              {\n                return allowParameters || this._parameters.size === 0;\n              }\n\n            default:\n              {\n                return false;\n              }\n          }\n        }\n\n      case \"application\":\n        {\n          switch (this._subtype) {\n            case \"ecmascript\":\n            case \"javascript\":\n            case \"x-ecmascript\":\n            case \"x-javascript\":\n              {\n                return allowParameters || this._parameters.size === 0;\n              }\n\n            default:\n              {\n                return false;\n              }\n          }\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n  }\n\n  isXML() {\n    return this._subtype === \"xml\" && (this._type === \"text\" || this._type === \"application\") || this._subtype.endsWith(\"+xml\");\n  }\n\n  isHTML() {\n    return this._subtype === \"html\" && this._type === \"text\";\n  }\n\n};\n\nclass MIMETypeParameters {\n  constructor(map) {\n    this._map = map;\n  }\n\n  get size() {\n    return this._map.size;\n  }\n\n  get(name) {\n    name = asciiLowercase(String(name));\n    return this._map.get(name);\n  }\n\n  has(name) {\n    name = asciiLowercase(String(name));\n    return this._map.has(name);\n  }\n\n  set(name, value) {\n    name = asciiLowercase(String(name));\n    value = String(value);\n\n    if (!solelyContainsHTTPTokenCodePoints(name)) {\n      throw new Error(\"Invalid MIME type parameter name \\\"\".concat(name, \"\\\": only HTTP token code points are valid.\"));\n    }\n\n    if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {\n      throw new Error(\"Invalid MIME type parameter value \\\"\".concat(value, \"\\\": only HTTP quoted-string token code points are \") + \"valid.\");\n    }\n\n    return this._map.set(name, value);\n  }\n\n  clear() {\n    this._map.clear();\n  }\n\n  delete(name) {\n    name = asciiLowercase(String(name));\n    return this._map.delete(name);\n  }\n\n  forEach(callbackFn, thisArg) {\n    this._map.forEach(callbackFn, thisArg);\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  values() {\n    return this._map.values();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  [Symbol.iterator]() {\n    return this._map[Symbol.iterator]();\n  }\n\n}","map":null,"metadata":{},"sourceType":"script"}