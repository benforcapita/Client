{"ast":null,"code":"\"use strict\";\n\nconst idlUtils = require(\"../generated/utils.js\");\n\nconst DOMException = require(\"domexception\");\n\nconst _require = require(\"../node-document-position\"),\n      DOCUMENT_POSITION_CONTAINS = _require.DOCUMENT_POSITION_CONTAINS,\n      DOCUMENT_POSITION_CONTAINED_BY = _require.DOCUMENT_POSITION_CONTAINED_BY;\n\nconst Element = require(\"../generated/Element\");\n\nconst Node = require(\"../generated/Node\");\n\nconst HTMLCollectionImpl = require(\"./HTMLCollection-impl\").implementation;\n\nexports.implementation = class HTMLOptionsCollectionImpl extends HTMLCollectionImpl {\n  // inherits supported property indices\n  get length() {\n    this._update();\n\n    return this._list.length;\n  }\n\n  set length(value) {\n    this._update();\n\n    if (value > this._list.length) {\n      const doc = this._element._ownerDocument;\n\n      for (let i = this._list.length; i < value; i++) {\n        const el = doc.createElement(\"option\");\n\n        this._element.appendChild(el);\n      }\n    } else if (value < this._list.length) {\n      for (let i = this._list.length - 1; i >= value; i--) {\n        const el = this._list[i];\n\n        this._element.removeChild(el);\n      }\n    }\n  }\n\n  get [idlUtils.supportedPropertyNames]() {\n    this._update();\n\n    const result = new Set();\n\n    for (const element of this._list) {\n      result.add(element.getAttribute(\"id\"));\n      result.add(element.getAttribute(\"name\"));\n    }\n\n    return result;\n  }\n\n  [idlUtils.indexedSetNew](index, value) {\n    if (value === null) {\n      this.remove(index);\n      return;\n    }\n\n    this._update();\n\n    const length = this._list.length;\n    const n = index - length;\n\n    if (n > 0) {\n      const doc = this._element._ownerDocument;\n      const frag = doc.createDocumentFragment(); // Spec says n - 1, but n seems to be the right number here.\n\n      for (let i = 0; i < n; i++) {\n        const el = doc.createElement(\"option\");\n        frag.appendChild(el);\n      }\n\n      this._element.appendChild(frag);\n    }\n\n    if (n >= 0) {\n      this._element.appendChild(value);\n    } else {\n      this._element.replaceChild(value, this._list[index]);\n    }\n  }\n\n  [idlUtils.indexedSetExisting](index, value) {\n    return this[idlUtils.indexedSetNew](index, value);\n  }\n\n  add(element, before) {\n    if (this._element.compareDocumentPosition(element) & DOCUMENT_POSITION_CONTAINS) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    if (Element.isImpl(before) && !(this._element.compareDocumentPosition(before) & DOCUMENT_POSITION_CONTAINED_BY)) {\n      throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n    }\n\n    if (element === before) {\n      return;\n    }\n\n    let reference = null;\n\n    if (Node.isImpl(before)) {\n      reference = before;\n    } else if (typeof before === \"number\") {\n      this._update();\n\n      reference = this._list[before] || null;\n    }\n\n    const parent = reference !== null ? reference.parentNode : this._element;\n    parent.insertBefore(element, reference);\n  }\n\n  remove(index) {\n    this._update();\n\n    if (this._list.length === 0) {\n      return;\n    }\n\n    if (index < 0 || index >= this._list.length) {\n      return;\n    }\n\n    const element = this._list[index];\n    element.parentNode.removeChild(element);\n  }\n\n  get selectedIndex() {\n    return this._element.selectedIndex;\n  }\n\n  set selectedIndex(value) {\n    this._element.selectedIndex = value;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}