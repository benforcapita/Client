{"ast":null,"code":"\"use strict\";\n\nconst _require = require(\"../helpers/internal-constants\"),\n      domSymbolTree = _require.domSymbolTree;\n\nconst _require2 = require(\"./helpers\"),\n      filter = _require2.filter,\n      FILTER_ACCEPT = _require2.FILTER_ACCEPT;\n\nexports.implementation = class NodeIteratorImpl {\n  constructor(constructorArgs, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n    this._referenceNode = this.root;\n    this._pointerBeforeReferenceNode = true; // This is used to deactive the NodeIterator if there are too many working in a Document at the same time.\n    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.\n    // This ensures we force a clean up of those beyond some maximum (specified by the Document).\n\n    this._working = true;\n    this._workingNodeIteratorsMax = privateData.workingNodeIteratorsMax;\n  }\n\n  get referenceNode() {\n    this._throwIfNotWorking();\n\n    return this._referenceNode;\n  }\n\n  get pointerBeforeReferenceNode() {\n    this._throwIfNotWorking();\n\n    return this._pointerBeforeReferenceNode;\n  }\n\n  nextNode() {\n    this._throwIfNotWorking();\n\n    return this._traverse(\"next\");\n  }\n\n  previousNode() {\n    this._throwIfNotWorking();\n\n    return this._traverse(\"previous\");\n  }\n\n  detach() {} // Intentionally do nothing, per spec.\n  // Called by Documents.\n\n\n  _preRemovingSteps(toBeRemovedNode) {\n    // Second clause is https://github.com/whatwg/dom/issues/496\n    if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {\n      return;\n    }\n\n    if (this._pointerBeforeReferenceNode) {\n      let next = null;\n      let candidateForNext = domSymbolTree.following(toBeRemovedNode, {\n        skipChildren: true\n      });\n\n      while (candidateForNext !== null) {\n        if (this.root.contains(candidateForNext)) {\n          next = candidateForNext;\n          break;\n        }\n\n        candidateForNext = domSymbolTree.following(candidateForNext, {\n          skipChildren: true\n        });\n      }\n\n      if (next !== null) {\n        this._referenceNode = next;\n        return;\n      }\n\n      this._pointerBeforeReferenceNode = false;\n    }\n\n    const previousSibling = toBeRemovedNode.previousSibling;\n    this._referenceNode = previousSibling === null ? toBeRemovedNode.parentNode : domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);\n  } // Only called by getters and methods that are affected by the pre-removing steps\n\n\n  _throwIfNotWorking() {\n    if (!this._working) {\n      throw Error(\"This NodeIterator is no longer working. More than \".concat(this._workingNodeIteratorsMax, \" iterators are \") + \"being used concurrently. You can increase the 'concurrentNodeIterators' option to make this error go away.\");\n    }\n  }\n\n  _traverse(direction) {\n    let node = this._referenceNode;\n    let beforeNode = this._pointerBeforeReferenceNode;\n\n    while (true) {\n      if (direction === \"next\") {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, {\n            root: this.root\n          });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = false;\n      } else if (direction === \"previous\") {\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, {\n            root: this.root\n          });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = true;\n      }\n\n      const result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        break;\n      }\n    }\n\n    this._referenceNode = node;\n    this._pointerBeforeReferenceNode = beforeNode;\n    return node;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}