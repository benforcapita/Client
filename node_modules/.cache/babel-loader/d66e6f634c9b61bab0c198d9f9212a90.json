{"ast":null,"code":"\"use strict\";\n\nconst whatwgURL = require(\"whatwg-url\");\n\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\n\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\n\nconst notImplemented = require(\"../../browser/not-implemented.js\");\n\nconst idlUtils = require(\"../generated/utils.js\"); // https://html.spec.whatwg.org/#session-history\n\n\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n\n      fn();\n    }, 0);\n\n    this._historyTraversalQueue.add(timeoutId);\n  }\n\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n\n    this._historyTraversalQueue.clear();\n  }\n\n  get length() {\n    return this._entries.length;\n  }\n\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  } // https://html.spec.whatwg.org/#dom-history-pushstate\n\n\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  } // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n\n\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n\n      const specifiedEntry = this._entries[newIndex]; // Not implemented: unload a document guard\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n        // this.clearHistoryTraversalTasks();\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  } // https://html.spec.whatwg.org/#traverse-the-history\n\n\n  traverseHistory(specifiedEntry, flags = {}) {\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    } // Not spec compliant, just minimal. Lots of missing steps.\n\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n    const document = idlUtils.implForWrapper(this._window._document);\n    const currentEntry = this.currentEntry; // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n\n    document._URL = specifiedEntry.url;\n    const hashChanged = specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL;\n    let newURL;\n\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n\n    this.updateCurrentEntry(specifiedEntry);\n    const state = specifiedEntry.stateObject; // TODO structured clone\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      this._windowImpl._dispatch(PopStateEvent.createImpl([\"popstate\", {\n        bubbles: false,\n        state\n      }], {\n        isTrusted: true\n      }));\n    }\n\n    if (hashChanged) {\n      this._windowImpl._dispatch(HashChangeEvent.createImpl([\"hashchange\", {\n        bubbles: false,\n        oldURL: whatwgURL.serializeURL(oldURL),\n        newURL: whatwgURL.serializeURL(newURL)\n      }], {\n        isTrusted: true\n      }));\n    }\n  }\n\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n\n}\n\nmodule.exports = SessionHistory;","map":null,"metadata":{},"sourceType":"script"}