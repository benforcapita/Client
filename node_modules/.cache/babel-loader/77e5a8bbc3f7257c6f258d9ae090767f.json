{"ast":null,"code":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nconst notImplemented = require(\"../../browser/not-implemented\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst _require = require(\"../../utils\"),\n      Canvas = _require.Canvas;\n\nclass HTMLCanvasElementImpl extends HTMLElementImpl {\n  _attrModified(name, value) {\n    if (this._canvas && (name === \"width\" || name === \"height\")) {\n      this._canvas[name] = parseInt(value);\n    }\n\n    return super._attrModified.apply(this, arguments);\n  }\n\n  _getCanvas() {\n    if (Canvas && !this._canvas) {\n      this._canvas = new Canvas(this.width, this.height);\n    }\n\n    return this._canvas;\n  }\n\n  getContext(contextId) {\n    const canvas = this._getCanvas();\n\n    if (canvas) {\n      if (!this._context) {\n        this._context = canvas.getContext(contextId) || null;\n\n        if (this._context) {\n          // Override the native canvas reference with our wrapper. This is the\n          // reason why we need to locally cache _context, since each call to\n          // canvas.getContext(contextId) would replace this reference again.\n          // Perhaps in the longer term, a better solution would be to create a\n          // full wrapper for the Context object as well.\n          this._context.canvas = idlUtils.wrapperForImpl(this);\n          wrapNodeCanvasMethod(this._context, \"createPattern\");\n          wrapNodeCanvasMethod(this._context, \"drawImage\");\n        }\n      }\n\n      return this._context;\n    }\n\n    notImplemented(\"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n    return null;\n  }\n\n  toDataURL() {\n    const canvas = this._getCanvas();\n\n    if (canvas) {\n      return canvas.toDataURL.apply(this._canvas, arguments);\n    }\n\n    notImplemented(\"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n    return null;\n  }\n\n  toBlob(callback, type, qualityArgument) {\n    const window = this._ownerDocument._defaultView;\n\n    const canvas = this._getCanvas();\n\n    if (canvas) {\n      let stream;\n\n      switch (type) {\n        case \"image/jpg\":\n        case \"image/jpeg\":\n          stream = canvas.createJPEGStream({\n            quality: Math.max(0, Math.min(1, qualityArgument)) * 100\n          });\n          break;\n\n        default:\n          // TODO: Patch node-canvas to receive qualityArgument for PNG stream\n          type = \"image/png\";\n          stream = canvas.createPNGStream();\n      }\n\n      const buffers = [];\n      stream.on(\"data\", chunk => {\n        buffers.push(chunk);\n      });\n      stream.on(\"end\", () => {\n        callback(new window.Blob(buffers, {\n          type\n        }));\n      });\n    } else {\n      notImplemented(\"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\", window);\n    }\n  }\n\n  get width() {\n    const parsed = parseInt(this.getAttribute(\"width\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n  }\n\n  set width(v) {\n    v = v > 2147483647 ? 300 : v;\n    this.setAttribute(\"width\", String(v));\n  }\n\n  get height() {\n    const parsed = parseInt(this.getAttribute(\"height\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n  }\n\n  set height(v) {\n    v = v > 2147483647 ? 150 : v;\n    this.setAttribute(\"height\", String(v));\n  }\n\n} // We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\n\n\nfunction wrapNodeCanvasMethod(ctx, name) {\n  const prev = ctx[name];\n\n  ctx[name] = function (image) {\n    const impl = idlUtils.implForWrapper(image);\n\n    if (impl) {\n      arguments[0] = impl._image || impl._canvas;\n    }\n\n    return prev.apply(ctx, arguments);\n  };\n}\n\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};","map":null,"metadata":{},"sourceType":"script"}